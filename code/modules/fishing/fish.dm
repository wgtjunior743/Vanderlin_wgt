#define FISH_SAD 0
#define FISH_VERY_HAPPY 4

#define FISH_SUBMERGING_THRESHOLD 100 SECONDS
#define STARVING_FISH_SUBMERGING_THRESHOLD 20 SECONDS

GLOBAL_LIST_INIT(fish_compatible_fluid_types, list(
	FISH_FLUID_ANY_WATER = list(FISH_FLUID_SALTWATER, FISH_FLUID_FRESHWATER, FISH_FLUID_SULPHWATEVER),
	FISH_FLUID_ANADROMOUS = list(FISH_FLUID_SALTWATER, FISH_FLUID_FRESHWATER),
	FISH_FLUID_SALTWATER = list(FISH_FLUID_SALTWATER),
	FISH_FLUID_FRESHWATER = list(FISH_FLUID_FRESHWATER),
	FISH_FLUID_SULPHWATEVER = list(FISH_FLUID_SULPHWATEVER),
	FISH_FLUID_AIR = list(FISH_FLUID_AIR),
))

// Fish path used for autogenerated fish
/obj/item/reagent_containers/food/snacks/fish
	abstract_type = /obj/item/reagent_containers/food/snacks/fish
	name = "fish"
	desc = "very bland"
	desc = ""
	icon_state = "carpcom"
	icon = 'icons/roguetown/misc/fish.dmi'
	verb_say = "glubs"
	verb_yell = "glubs"
	obj_flags = CAN_BE_HIT
	max_integrity = 50
	sellprice = 10
	dropshrink = 0.6
	slices_num = 1
	slice_bclass = BCLASS_CHOP
	faretype = FARE_IMPOVERISHED //incase someone decides to eat raw fish
	list_reagents = list(/datum/reagent/consumable/nutriment = 3)
	slice_path = /obj/item/reagent_containers/food/snacks/meat/mince/fish
	eat_effect = /datum/status_effect/debuff/uncookedfood
	fishloot = list(/obj/item/reagent_containers/food/snacks/fish/carp = 2)

	/// Flags for fish variables that would otherwise be TRUE/FALSE
	var/fish_flags = FISH_FLAG_SHOW_IN_CATALOG|FISH_DO_FLOP_ANIM

	/// Required fluid type for this fish to live.
	var/required_fluid_type = FISH_FLUID_FRESHWATER
	/// Required minimum temperature for the fish to live.
	var/required_temperature_min = MIN_AQUARIUM_TEMP
	/// Maximum possible temperature for the fish to live.
	var/required_temperature_max = MAX_AQUARIUM_TEMP

	/// What type of reagent this fish needs to be fed.
	var/datum/reagent/food = /datum/reagent/consumable/nutriment
	/// How often the fish needs to be fed
	var/feeding_frequency = 5 MINUTES
	/// Time of last the fish was fed
	var/last_feeding

	/// Fish status
	var/status = FISH_ALIVE
	///icon used when the fish is dead, ifset.
	var/icon_state_dead

	/// The message shown when the fish dies.
	var/death_text = "%SRC dies."

	/// The time limit before new fish can be created
	var/breeding_wait
	/// How long it takes to produce new fish
	var/breeding_timeout = 2 MINUTES
	/// If set, the fish can also breed with these fishes types
	var/list/compatible_types
	/// If set, when procreating these are the types of fish that will be generate instead of 'type'
	var/list/spawn_types

	///our fishes beauty
	var/beauty = 0

	// Fishing related properties

	/**
	 * List of fish trait types, these may modify probabilty/difficulty depending on rod/user properties
	 * or dictate how the fish behaves or some of its qualities.
	 */
	var/list/fish_traits = list()

	/// path to datums that dictate how the fish moves during the fishing minigame
	var/fish_movement_type = /datum/fish_movement

	/// Base additive modifier to fishing difficulty
	var/fishing_difficulty_modifier = 0

	/**
	 * Bait identifiers that make catching this fish easier and more likely
	 * Bait identifiers: Path | Trait | list("Type"="Foodtype","Value"= Food Type Flag like [MEAT])
	 */
	var/list/favorite_bait = list()

	/**
	 * Bait identifiers that make catching this fish harder and less likely
	 * Bait identifiers: Path | Trait | list("Type"="Foodtype","Value"= Food Type Flag like [MEAT])
	 */
	var/list/disliked_bait = list()

	/// Size in centimeters. Null until update_size_and_weight is called. Number of fillets and w_class scale with it.
	var/size
	/// Average size for this fish type in centimeters. Will be used as gaussian distribution with 20% deviation for fishing, bought fish are always standard size
	var/average_size = 50
	/// Temporarily stores the new size of the fish from randomize_size_and_weight() to be used by update_size_weight() later, so that it can be deferred.
	var/temp_size
	/// The maximum size this fish can reach, calculated the first time update_size_and_weight() is called.
	var/maximum_size

	/// Weight in grams. Null until update_size_and_weight is called. Grind results scale with it. Don't think too hard how a trout could fit in a blender.
	var/weight
	/// Average weight for this fish type in grams
	var/average_weight = 1000
	/// Temporarily stores the new weight of the fish from randomize_size_and_weight() to be used by update_size_weight() later, so that it can be deferred.
	var/temp_weight
	/// The maximum weight this fish can reach, calculated the first time update_size_and_weight() is called.
	var/maximum_weight
	/// Stores the current total weight modifier from materials.
	var/material_weight_mult = 1

	///The general deviation from the average weight and size this fish has in the wild
	var/weight_size_deviation = 0.2

	/// Set and used by trophy mounts, this one is for the name of who mounted it (might actually not be the catcher but w/e)
	var/catcher_name
	/// Set and used by trophy mounts, this is for the day of when it was first mounted
	var/catch_date

	/**
	 * If you wonder why this isn't being tracked by the edible component instead:
	 * We reset the this value when revived, and slowly chip it away as we heal.
	 * Of course, it would be daunting to get this to be handled by the edible component
	 * given its complexity.
	 */
	var/bites_amount = 0

	/**
	 * An identifier for this fish used to track progress for fish caught between rounds in
	 * a way that's resilient to repathing (and removing paths). Only catchable fish need it.
	 * Once set, the value shouldn't be changed, so don't make typos.
	 */
	var/fish_id
	///Used to redirect to another fish path so that catching this fish unlocks its entry instead.
	var/obj/item/reagent_containers/food/snacks/fish/fish_id_redirect_path
	/// only used in the suicide for comedic value
	var/suicide_slap_text = "*SLAP!*"

	var/time_passed_on_safe_turf = 0

/obj/item/reagent_containers/food/snacks/fish/proc/generate_html(mob/user)
	var/client/client = user
	if(!istype(client))
		client = user.client
	SSassets.transport.send_assets(client, list("try4_border.png", "try4.png", "slop_menustyle2.css"))
	user << browse_rsc('html/book.png')

	var/html = {"
		<!DOCTYPE html>
		<html>
		<head>
			<link rel="stylesheet" type="text/css" href="slop_menustyle2.css">
			<style>
				.fish-entry {
					border: 2px solid #4a90e2;
					margin: 10px 0;
					padding: 10px;
					background-color: #1a1a2e;
				}
				.fish-stat {
					margin: 5px 0;
					padding-left: 10px;
				}
				.stat-label {
					color: #4a90e2;
					font-weight: bold;
				}
				.difficulty-easy { color: #5cb85c; }
				.difficulty-medium { color: #f0ad4e; }
				.difficulty-hard { color: #d9534f; }
				.trait-item {
					padding: 5px;
					margin: 3px 0;
					border-left: 3px solid #e94560;
				}
				.lure-item {
					padding: 5px;
					margin: 3px 0;
					border-left: 3px solid #4a90e2;
				}
			</style>
		</head>
		<body>
			<div class='book'>
				<div class='page'>
					<h1>[name]</h1>
					<div class='info'>
						<img src='\ref[icon]?state=[icon_state]&dir=2' style='display: block; margin: 0 auto; transform: scale(3);' />
						<p class='desc'>[desc]</p>
					</div>
	"}

	html += "<div class='section'><h2>Physical Properties</h2>"
	html += "<div class='fish-stat'><span class='stat-label'>Average Size:</span> [average_size] cm</div>"
	html += "<div class='fish-stat'><span class='stat-label'>Average Size:</span> [average_weight] g</div>"
	html += "<div class='fish-stat'><span class='stat-label'>Beauty Score:</span> [SSfishing.fish_properties[type][FISH_PROPERTIES_BEAUTY_SCORE]]</div>"
	html += "</div>"

	html += "<div class='section'><h2>Environmental Requirements</h2>"
	html += "<div class='fish-stat'><span class='stat-label'>Required Fluid:</span> [required_fluid_type]</div>"
	html += "<div class='fish-stat'><span class='stat-label'>Temperature Range:</span> [required_temperature_min]°C - [required_temperature_max]°C</div>"
	html += "</div>"

	html += "<div class='section'><h2>Feeding</h2>"
	var/datum/reagent/food_type = food
	if(food_type != /datum/reagent/consumable/nutriment)
		html += "<div class='fish-stat'><span class='stat-label'>Preferred Food:</span> [initial(food_type.name)]</div>"
	else
		html += "<div class='fish-stat'><span class='stat-label'>Preferred Food:</span> Fish Feed</div>"
	html += "</div>"

	var/list/fishing_tips = build_fishing_tips()
	html += "<div class='section'><h2>Fishing Information</h2>"

	html += "<div class='fish-stat'><span class='stat-label'>Found at:</span> [fishing_tips["spots"]]</div>"

	var/difficulty_class = "difficulty-[lowertext(fishing_tips["difficulty"])]"
	html += "<div class='fish-stat'><span class='stat-label'>Difficulty:</span> <span class='[difficulty_class]'>[fishing_tips["difficulty"]]</span></div>"

	html += "<div class='fish-stat'><span class='stat-label'>Favorite Bait:</span> [fishing_tips["favorite_bait"]]</div>"

	html += "<div class='fish-stat'><span class='stat-label'>Disliked Bait:</span> [fishing_tips["disliked_bait"]]</div>"

	html += "<div class='fish-stat'><span class='stat-label'>Compatible Lures & Bait:</span></div>"
	for(var/lure_name in fishing_tips["lures"])
		html += "<div class='lure-item'>• [lure_name]</div>"

	html += "<div class='fish-stat'><span class='stat-label'>Behavior:</span></div>"
	for(var/trait_desc in fishing_tips["traits"])
		html += "<div class='trait-item'>• [trait_desc]</div>"

	html += "</div>"

	html += {"
				</div>
			</div>
		</body>
		</html>
	"}
	return html

/obj/item/reagent_containers/food/snacks/fish/proc/show_menu(mob/user)
	user << browse(generate_html(user), "window=fish_catalog;size=600x900")

/obj/item/reagent_containers/food/snacks/fish/proc/bait_description(bait)
	if(ispath(bait))
		var/obj/bait_item = bait
		return initial(bait_item.name)
	if(islist(bait))
		var/list/special_identifier = bait
		switch(special_identifier[FISH_BAIT_TYPE])
			if(FISH_BAIT_FOODTYPE)
				return jointext(bitfield_to_list(special_identifier[FISH_BAIT_VALUE], FOOD_FLAGS_IC), ",")
			if(FISH_BAIT_REAGENT)
				var/datum/reagent/prototype = special_identifier[FISH_BAIT_VALUE]
				return "[initial(prototype.name)] (at least [special_identifier[FISH_BAIT_AMOUNT]]u)"
			else
				stack_trace("Unknown bait identifier in fish favourite/disliked list")
				return "SOMETHING VERY WEIRD"
	else
		return "something special"

/obj/item/reagent_containers/food/snacks/fish/proc/build_fishing_tips()
	. = list()

	// Where can it be found
	var/list/spot_descriptions = list()
	for(var/datum/fish_source/source as anything in GLOB.preset_fish_sources)
		var/datum/fish_source/source_table =  GLOB.preset_fish_sources[source]
		if(source_table.catalog_description && (type in source_table.fish_table))
			spot_descriptions += source_table.catalog_description
	.["spots"] = english_list(spot_descriptions, nothing_text = "Unknown")

	var/list/fish_list_properties = SSfishing.fish_properties
	var/list/fav_bait = fish_list_properties[type][FISH_PROPERTIES_FAV_BAIT]
	var/list/disliked_bait = fish_list_properties[type][FISH_PROPERTIES_BAD_BAIT]
	var/list/bait_list = list()

	for(var/bait_type_or_trait in fav_bait)
		bait_list += bait_description(bait_type_or_trait)
	.["favorite_bait"] = english_list(bait_list, nothing_text = "None")
	bait_list.Cut()

	for(var/bait_type_or_trait in disliked_bait)
		bait_list += bait_description(bait_type_or_trait)
	.["disliked_bait"] = english_list(bait_list, nothing_text = "None")

	var/list/compatible_lures = list()
	for(var/lure_type in SSfishing.lure_catchables)
		if(type in SSfishing.lure_catchables[lure_type])
			var/obj/item/fishing/lure/lure_path = lure_type
			if(ispath(lure_path, /obj/item/fishing/lure/no_bait))
				continue
			compatible_lures += initial(lure_path.name)
	.["lures"] = compatible_lures.len ? compatible_lures : list("None (use bait only)")

	var/list/trait_descriptions = list()
	var/list/fish_traits = fish_list_properties[type][FISH_PROPERTIES_TRAITS]
	var/fish_difficulty = fishing_difficulty_modifier
	for(var/fish_trait in fish_traits)
		var/datum/fish_trait/trait = GLOB.fish_traits[fish_trait]
		trait_descriptions += trait.catalog_description
		fish_difficulty += trait.added_difficulty
	if(!length(trait_descriptions))
		trait_descriptions += "This fish exhibits no special behavior."
	.["traits"] = trait_descriptions

	switch(fish_difficulty)
		if(-INFINITY to 9)
			.["difficulty"] = "Easy"
		if(10 to 19)
			.["difficulty"] = "Medium"
		else
			.["difficulty"] = "Hard"

	return .

/obj/item/reagent_containers/food/snacks/fish/Initialize(mapload, apply_qualities = TRUE)
	. = ..()
	base_icon_state = icon_state

	if(fish_flags & FISH_DO_FLOP_ANIM)
		RegisterSignal(src, COMSIG_ATOM_TEMPORARY_ANIMATION_START, PROC_REF(on_temp_animation))
		check_flopping()
	if(status != FISH_DEAD)
		START_PROCESSING(SSobj, src)

	RegisterSignal(src, SIGNAL_ADDTRAIT(TRAIT_FISH_STASIS), PROC_REF(enter_stasis))
	RegisterSignal(src, SIGNAL_REMOVETRAIT(TRAIT_FISH_STASIS), PROC_REF(exit_stasis))


	//stops new fish from being able to reproduce right away.
	breeding_wait = world.time + (breeding_timeout * NEW_FISH_BREEDING_TIMEOUT_MULT)
	last_feeding = world.time - (feeding_frequency * NEW_FISH_LAST_FEEDING_MULT)

	if(apply_qualities)
		apply_traits() //Make sure traits are applied before size and weight.
		update_size_and_weight()

/obj/item/reagent_containers/food/snacks/fish/proc/released(atom/location, mob/living/user)
	playsound(location, 'sound/effects/splash.ogg', 50)
	SEND_SIGNAL(location, COMSIG_FISH_RELEASED_INTO, src, user)
	qdel(src)

///Main proc that makes the fish edible.
/obj/item/reagent_containers/food/snacks/fish/proc/make_edible()
	var/bites_to_finish = weight / FISH_WEIGHT_BITE_DIVISOR
	create_reagents(INFINITY) //We'll set this to the total volume of the reagents right after generate_fish_reagents() is over
	generate_fish_reagents(bites_to_finish)
	reagents.maximum_volume = round(reagents.total_volume * 1.25) //make some meager space for condiments.

/**
 * Fish is not a reagent holder yet it's edible, so it doen't behave like most other snacks
 * which means it has its own way of handling being bitten, which is defined here.
 */
/obj/item/reagent_containers/food/snacks/fish/proc/after_eat(mob/living/eater, mob/living/feeder)
	SHOULD_CALL_PARENT(TRUE)
	if(!reagents.total_volume)
		return
	bites_amount++
	var/bites_to_finish = weight / FISH_WEIGHT_BITE_DIVISOR
	damage_fish((max_integrity / bites_to_finish) * 3)
	flinch_on_eat(eater, feeder)

/obj/item/reagent_containers/food/snacks/fish/proc/flinch_on_eat(mob/living/eater, mob/living/feeder)
	if(status == FISH_ALIVE && prob(50) && feeder.is_holding(src) && feeder.dropItemToGround(src))
		to_chat(feeder, span_warning("[src] slips out of your hands in pain!"))
		var/turf/target_turf = get_ranged_target_turf(get_turf(src), pick(GLOB.alldirs), 2)
		throw_at(target_turf)

///A proc that returns a static reagent holder with a set reagents that you'd get when eating this fish.
/obj/item/reagent_containers/food/snacks/fish/proc/generate_fish_reagents(multiplier = 1)
	SHOULD_NOT_OVERRIDE(TRUE)
	var/list/reagents_to_add = get_base_edible_reagents_to_add()
	SEND_SIGNAL(src, COMSIG_GENERATE_REAGENTS_TO_ADD, reagents_to_add)
	if(multiplier != 1)
		for(var/reagent in reagents_to_add)
			reagents_to_add[reagent] *= multiplier
	reagents.add_reagent_list(reagents_to_add)

/obj/item/reagent_containers/food/snacks/fish/proc/get_fish_taste()
	return list("raw fish" = 2.5, "scales" = 1)

/obj/item/reagent_containers/food/snacks/fish/proc/get_fish_taste_cooked()
	return list("cooked fish" = 2)

///The proc that adds in the main reagents this fish has when eaten (without accounting for traits)
/obj/item/reagent_containers/food/snacks/fish/proc/get_base_edible_reagents_to_add()
	var/return_list = list(
		/datum/reagent/consumable/nutriment = 2,
		/datum/reagent/blood = 1,
	)
	if(required_fluid_type == FISH_FLUID_SALTWATER)
		return_list[/datum/reagent/flour] = 0.4
	return return_list

///adjusts the maximum volume of the fish reagents holder and update the amount of food to bite
/obj/item/reagent_containers/food/snacks/fish/proc/adjust_reagents_capacity(amount_to_add)
	if(!reagents)
		return
	reagents.maximum_volume += amount_to_add

/obj/item/reagent_containers/food/snacks/fish/update_icon_state()
	if((status == FISH_DEAD || HAS_TRAIT(src, TRAIT_FISH_STASIS)) && icon_state_dead)
		icon_state = icon_state_dead
	else
		icon_state = base_icon_state
	return ..()

/*
/obj/item/reagent_containers/food/snacks/fish/attackby(obj/item/item, mob/living/user, list/modifiers, list/attack_modifiers)
	if(!istype(item, /obj/item/reagent_containers/cup/fish_feed))
		return ..()
	if(!item.reagents.total_volume)
		balloon_alert(user, "[item.name] is empty!")
		return TRUE
	if(status == FISH_DEAD)
		balloon_alert(user, "[name] is dead!")
		return TRUE
	feed(item.reagents)
	balloon_alert(user, "fed [name]")
	return TRUE
*/

/obj/item/reagent_containers/food/snacks/fish/examine(mob/user)
	. = ..()
	if(catcher_name && catch_date)
		. += span_green("Caught by [catcher_name] on [catch_date].")

	. += span_notice("It's [size] cm long.")
	. += span_notice("It weighs [weight] g.")

	. += get_health_warnings(user, always_deep = FALSE)

	if(HAS_TRAIT(src, TRAIT_FISHING_BAIT))
		. += span_smallnoticeital("It can be used as a fishing bait.")

	if(bites_amount)
		. += span_warning("It's been bitten by someone.")

/obj/item/reagent_containers/food/snacks/fish/proc/get_health_warnings(mob/user, always_deep = FALSE)
	if(!always_deep)
		return
	if(status == FISH_DEAD)
		return span_deadsay("It's dead.")

	var/list/warnings = list()
	if(get_starvation_mult())
		warnings += "starving"
	if(!HAS_TRAIT(src, TRAIT_FISH_STASIS) && !proper_environment())
		warnings += "drowning"

	var/health_ratio = get_health_percentage()
	switch(health_ratio)
		if(0 to 0.25)
			warnings += "dying"
		if(0.25 to 0.5)
			warnings += "very unhealthy"
		if(0.5 to 0.75)
			warnings += "unhealthy"
		if(0.75 to 0.9)
			warnings += "mostly healthy"

	if(length(warnings))
		. += span_warning("It's [english_list(warnings)].")

	return .

/**
 * This proc takes a base size, base weight and deviation arguments to generate new size and weight through a gaussian distribution (bell curve)
 * Mainly used to determinate the size and weight of caught fish.
 */
/obj/item/reagent_containers/food/snacks/fish/proc/randomize_size_and_weight(base_size = average_size, base_weight = average_weight, deviation = weight_size_deviation, update = TRUE)
	var/size_deviation = 0.2 * base_size
	temp_size = round(clamp(gaussian(base_size, size_deviation), average_size * 1/MAX_FISH_DEVIATION_COEFF, average_size * MAX_FISH_DEVIATION_COEFF))

	var/weight_deviation = 0.2 * base_weight
	temp_weight = round(clamp(gaussian(base_weight, weight_deviation), average_weight * 1/MAX_FISH_DEVIATION_COEFF, average_weight * MAX_FISH_DEVIATION_COEFF))

	set_max_size_and_weight(temp_size, temp_weight)
	if(update)
		update_size_and_weight(temp_size, temp_weight)

///Set the maximum size and weight a fish can reach from base size and weight args if they have't been set already.
/obj/item/reagent_containers/food/snacks/fish/proc/set_max_size_and_weight(base_size, base_weight)
	if(!maximum_size)
		maximum_size = min(base_size * 2, average_size * MAX_FISH_DEVIATION_COEFF)
	if(!maximum_weight)
		maximum_weight = min(base_weight * 2, average_weight * MAX_FISH_DEVIATION_COEFF)

///Updates weight and size, along with weight class, number of fillets you can get and grind results.
/obj/item/reagent_containers/food/snacks/fish/proc/update_size_and_weight(new_size = average_size, new_weight = average_weight, update_materials = TRUE)
	fish_flags |= FISH_FLAG_UPDATING_SIZE_AND_WEIGHT
	SEND_SIGNAL(src, COMSIG_FISH_UPDATE_SIZE_AND_WEIGHT, new_size, new_weight)

	if(size)
		if(size > FISH_SIZE_TWO_HANDS_REQUIRED)
			qdel(GetComponent(/datum/component/two_handed))
	else
		set_max_size_and_weight(new_size, new_weight)

	size = new_size

	switch(size)
		if(0 to FISH_SIZE_TINY_MAX)
			w_class = WEIGHT_CLASS_TINY
		if(FISH_SIZE_TINY_MAX to FISH_SIZE_SMALL_MAX)
			w_class = WEIGHT_CLASS_SMALL
		if(FISH_SIZE_SMALL_MAX to FISH_SIZE_NORMAL_MAX)
			w_class = WEIGHT_CLASS_NORMAL
		if(FISH_SIZE_NORMAL_MAX to FISH_SIZE_BULKY_MAX)
			w_class = WEIGHT_CLASS_BULKY
		if(FISH_SIZE_BULKY_MAX to FISH_SIZE_HUGE_MAX)
			w_class = WEIGHT_CLASS_HUGE
		if(FISH_SIZE_HUGE_MAX to INFINITY)
			w_class = WEIGHT_CLASS_GIGANTIC

	if(size > FISH_SIZE_TWO_HANDS_REQUIRED || (HAS_TRAIT(src, TRAIT_FISH_SHOULD_TWOHANDED) && w_class >= WEIGHT_CLASS_BULKY))
		AddComponent(/datum/component/two_handed, require_twohands = TRUE)

	var/make_edible = !weight
	if(weight)
		for(var/reagent_type in grind_results)
			grind_results[reagent_type] /= max(FLOOR(weight/FISH_GRIND_RESULTS_WEIGHT_DIVISOR, 0.1), 0.1)
		if(reagents) //This fish has reagents. Adjust the maximum volume of the reagent holder and do some math to adjut the reagents too.
			var/new_weight_ratio = new_weight / weight
			var/volume_diff = reagents.maximum_volume * new_weight_ratio - reagents.maximum_volume
			if(new_weight_ratio > weight)
				adjust_reagents_capacity(volume_diff)
				///As always, we want to maintain proportions here, so we need to get the ratio of bites left and initial bites left.
				var/weight_diff = new_weight - weight
				var/multiplier = weight_diff / FISH_WEIGHT_BITE_DIVISOR
				var/initial_bites_left = weight / FISH_WEIGHT_BITE_DIVISOR
				var/bites_left = initial_bites_left - bites_amount
				var/amount_to_gen = bites_left / initial_bites_left * multiplier
				generate_fish_reagents(amount_to_gen)
			else
				reagents.multiply(new_weight_ratio)
				adjust_reagents_capacity(volume_diff)

	weight = new_weight

	if(make_edible)
		make_edible()

	if(weight >= FISH_WEIGHT_SLOWDOWN)
		slowdown = GET_FISH_SLOWDOWN(weight)
		drag_slowdown = round(slowdown * 0.5, 1)
	else
		slowdown = 0
		drag_slowdown = 0
	if(ismob(loc))
		var/mob/mob = loc
		mob.update_equipment_speed_mods()

	for(var/reagent_type in grind_results)
		grind_results[reagent_type] *= max(FLOOR(weight/average_weight, 0.1), 0.1)

	update_fish_force()

	slices_num = max(round(slices_num * size / FISH_FILLET_NUMBER_SIZE_DIVISOR, 1), 1)
	sellprice = initial(sellprice) * (1 + (max(FLOOR(weight/average_weight, 0.1), 0.1) - 1))
	fish_flags &= ~FISH_FLAG_UPDATING_SIZE_AND_WEIGHT

///Reset weapon-related variables of this items and recalculates those values based on the fish weight and size.
/obj/item/reagent_containers/food/snacks/fish/proc/update_fish_force()
	if(force >= 15 && hitsound == SFX_ALT_FISH_SLAP)
		hitsound = SFX_DEFAULT_FISH_SLAP
	force = initial(force)
	throwforce = initial(throwforce)
	throw_range = initial(throw_range)
	hitsound = initial(hitsound)
	damtype = initial(damtype)
	block_chance = initial(block_chance)
	armor_penetration = initial(armor_penetration)
	toolspeed = initial(toolspeed)

	var/weight_rank = GET_FISH_WEIGHT_RANK(weight)

	throw_range -= weight_rank
	get_force_rank()

	var/bonus_malus = weight_rank - w_class
	if(bonus_malus)
		calculate_fish_force_bonus(bonus_malus)

	SEND_SIGNAL(src, COMSIG_FISH_FORCE_UPDATED, weight_rank, bonus_malus)

	throwforce = force

	if(force >=15 && hitsound == SFX_DEFAULT_FISH_SLAP) // don't override special attack sounds
		hitsound = SFX_ALT_FISH_SLAP // do more damage - do heavier slap sound

///A proc that makes the fish slightly stronger or weaker if there's a noticeable discrepancy between size and weight.
/obj/item/reagent_containers/food/snacks/fish/proc/calculate_fish_force_bonus(bonus_malus)
	force = round(force * (1 + bonus_malus * 0.1), 0.1)

/obj/item/reagent_containers/food/snacks/fish/proc/get_force_rank()
	switch(w_class)
		if(WEIGHT_CLASS_TINY)
			force -= 3
		if(WEIGHT_CLASS_NORMAL)
			force += 2
		if(WEIGHT_CLASS_BULKY)
			force += 5
		if(WEIGHT_CLASS_HUGE)
			force += 9
		if(WEIGHT_CLASS_GIGANTIC)
			force += 13


/**
 * This proc has fish_traits list populated with fish_traits paths from three different lists:
 * traits from x_traits and y_traits are compared, and inserted if conditions are met;
 * traits from fixed_traits are inserted unconditionally.
 * traits from removed_traits will be removed from the for loop.
 *
 * This proc should only be called if the fish was spawned with the apply_qualities arg set to FALSE
 * and hasn't had inherited traits already.
 */
/obj/item/reagent_containers/food/snacks/fish/proc/inherit_traits(list/x_traits, list/y_traits, list/fixed_traits, list/removed_traits)

	fish_traits = fixed_traits?.Copy() || list()

	var/list/same_traits = x_traits & y_traits
	var/list/all_traits = (y_traits ? (x_traits|y_traits) : x_traits) - removed_traits

	/// a list of incompatible traits that'll be filled as it goes on. Don't let any such trait pass onto the fish.
	var/list/incompatible_traits = list()

	///some traits can spontaneously manifest for some fishes. These have higher priorities than other traits
	var/list/potential_spontaneous_traits = GLOB.spontaneous_fish_traits[type]
	for(var/trait_type in potential_spontaneous_traits)
		if(!prob(potential_spontaneous_traits[trait_type]))
			continue
		var/datum/fish_trait/trait = GLOB.fish_traits[trait_type]
		if(length(fish_traits & trait.incompatible_traits))
			continue
		fish_traits |= trait_type
		incompatible_traits |= trait.incompatible_traits

	for(var/trait_type in fish_traits)
		var/datum/fish_trait/trait = GLOB.fish_traits[trait_type]
		incompatible_traits |= trait.incompatible_traits
	/**
	 * shuffle the traits, so, in the case of incompatible traits, we don't have to choose which to discard.
	 * Instead we let the random numbers do it for us in a first come, first served basis.
	 */
	for(var/trait_type in shuffle(all_traits))
		if(trait_type in fish_traits)
			continue //likely a fixed trait
		if(trait_type in incompatible_traits)
			continue
		var/datum/fish_trait/trait = GLOB.fish_traits[trait_type]
		if(isnull(trait))
			stack_trace("Couldn't find trait [trait_type || "null"] in the global fish traits list")
			continue
		if(!isnull(trait.fish_whitelist) && !(type in trait.fish_whitelist))
			continue
		if(length(fish_traits & trait.incompatible_traits))
			continue
		// If there's no partner, we've been reated through parthenogenesis or growth, therefore, traits are copied
		// Otherwise, we check if both have the trait or perform a probability check.
		if(!y_traits || (trait_type in same_traits) || prob(trait.inheritability))
			fish_traits |= trait_type
			incompatible_traits |= trait.incompatible_traits

	apply_traits()

/obj/item/reagent_containers/food/snacks/fish/proc/apply_traits()
	for(var/fish_trait_type in fish_traits)
		var/datum/fish_trait/trait = GLOB.fish_traits[fish_trait_type]
		trait.apply_to_fish(src)

/obj/item/reagent_containers/food/snacks/fish/Moved(atom/old_loc, movement_dir, forced, list/old_locs, momentum_change = TRUE)
	. = ..()
	check_flopping()

/// Stop processing once the stasis trait is added
/obj/item/reagent_containers/food/snacks/fish/proc/enter_stasis(datum/source)
	SIGNAL_HANDLER
	stop_flopping()
	update_appearance()
	STOP_PROCESSING(SSobj, src)

/// Start processing again when the stasis trait is removed
/obj/item/reagent_containers/food/snacks/fish/proc/exit_stasis(datum/source)
	SIGNAL_HANDLER
	if(status == FISH_DEAD)
		return
	START_PROCESSING(SSobj, src)
	check_flopping()

///Returns the value for hunger ranging from 0 to the cap (by default 1)
/obj/item/reagent_containers/food/snacks/fish/proc/get_hunger(cap = FISH_STARVING_THRESHOLD)
	. = clamp((world.time - last_feeding) / feeding_frequency, 0, cap)
	if(HAS_TRAIT(src, TRAIT_FISH_NO_HUNGER))
		return min(., FISH_STARVING_THRESHOLD * 0.2)

/obj/item/reagent_containers/food/snacks/fish/proc/get_starvation_mult()
	var/hunger = get_hunger(cap = FISH_STARVING_THRESHOLD * 2)
	return hunger >= FISH_STARVING_THRESHOLD ? hunger : 0

///Feed the fishes with the contents of the fish feed
/obj/item/reagent_containers/food/snacks/fish/proc/feed(datum/reagents/fed_reagents)
	if(status != FISH_ALIVE)
		return

	///If one of the reagent with fish effects is also our food reagent this is set to TRUE
	var/already_fed = FALSE
	var/was_hungry = get_hunger()
	for(var/datum/reagent/reagent as anything in fed_reagents.reagent_list)
		if(!fed_reagents.has_reagent(reagent.type, 0.1))
			continue
		fed_reagents.remove_reagent(reagent.type, 0.1)
		if(reagent.type == food)
			already_fed = TRUE

	if(was_hungry && !get_hunger()) //one of the other reagents already sated its hunger.
		return

	if(already_fed)
		sate_hunger()
		return

	if(fed_reagents.remove_reagent(food, 0.1))
		sate_hunger()
		return

	var/datum/reagent/wrong_reagent = pick(fed_reagents.reagent_list)
	if(!wrong_reagent)
		return
	fed_reagents.remove_reagent(wrong_reagent.type, 0.1)

///Proc that should be called when the fish is fed. By default, it grows the fish depending on various variables.
/obj/item/reagent_containers/food/snacks/fish/proc/sate_hunger()
	var/hunger = get_hunger()
	last_feeding = world.time
	if(hunger < 0.05) //don't bother growing for very small amounts.
		return

	var/new_size = size
	var/new_weight = weight
	var/hunger_mult
	if(hunger <= FISH_GROWTH_PEAK)
		hunger_mult = hunger / FISH_GROWTH_PEAK
	else
		hunger_mult = 1 - (hunger - FISH_GROWTH_PEAK) * 4
		if(hunger_mult <= 0)
			return
	var/base_mult = FISH_GROWTH_MULT
	if(HAS_TRAIT(src, TRAIT_FISH_QUICK_GROWTH))
		base_mult *= 2.5
	if(size < maximum_size)
		new_size += CEILING((maximum_size - size) * base_mult / (w_class * FISH_SIZE_WEIGHT_GROWTH_MALUS) * hunger_mult, 1)
		new_size = min(new_size, maximum_size)
	if(weight < maximum_weight)
		new_weight += CEILING((maximum_weight - weight) * base_mult / (GET_FISH_WEIGHT_RANK(weight) * FISH_SIZE_WEIGHT_GROWTH_MALUS) * hunger_mult, 1)
		new_weight = min(new_weight, maximum_weight)
	if(new_size != size || new_weight != weight)
		update_size_and_weight(new_size, new_weight)

/obj/item/reagent_containers/food/snacks/fish/proc/check_flopping()
	if(QDELETED(src)) //we don't care anymore
		return

	if(!(fish_flags & FISH_DO_FLOP_ANIM))
		return

	// Do additional stuff
	// Start flopping if outside of fish container
	var/should_be_flopping = status == FISH_ALIVE && (loc && !HAS_TRAIT(loc, TRAIT_STOP_FISH_FLOPPING))

	if(should_be_flopping)
		start_flopping()
	else
		stop_flopping()

/obj/item/reagent_containers/food/snacks/fish/process(seconds_per_tick)
	if(HAS_TRAIT(src, TRAIT_FISH_STASIS) || status != FISH_ALIVE)
		return
	do_fish_process(seconds_per_tick)
	if(status != FISH_ALIVE || !is_type_in_typecache(loc, SSfishing.fish_safe_turfs_by_type[type]))
		time_passed_on_safe_turf = 0 SECONDS
		return
	time_passed_on_safe_turf += seconds_per_tick SECONDS
	if(time_passed_on_safe_turf >= (get_starvation_mult() ? STARVING_FISH_SUBMERGING_THRESHOLD : FISH_SUBMERGING_THRESHOLD))
		visible_message(span_notice("[src] disperses into \the [loc]"), span_notice("You hear a splash."))
		released(loc)

/obj/item/reagent_containers/food/snacks/fish/proc/do_fish_process(seconds_per_tick)
	//safe mode, don't do much except a few things that don't involve growing or reproducing.
	if(loc)
		last_feeding += seconds_per_tick SECONDS
		breeding_wait += seconds_per_tick SECONDS
	else
		process_health(seconds_per_tick)

	SEND_SIGNAL(src, COMSIG_FISH_LIFE, seconds_per_tick)

/obj/item/reagent_containers/food/snacks/fish/proc/set_status(new_status, silent = FALSE)
	if(status == new_status)
		return
	switch(new_status)
		if(FISH_ALIVE)
			status = FISH_ALIVE
			repair_damage(max_integrity)
			regenerate_bites(bites_amount)
			last_feeding = world.time //reset hunger
			check_flopping()
			START_PROCESSING(SSobj, src)
		if(FISH_DEAD)
			status = FISH_DEAD
			STOP_PROCESSING(SSobj, src)
			stop_flopping()
			if(!silent)
				var/message = span_warning(replacetext(death_text, "%SRC", "[src]"))
				visible_message(message)
	update_appearance()
	update_fish_force()
	SEND_SIGNAL(src, COMSIG_FISH_STATUS_CHANGED)

/obj/item/reagent_containers/food/snacks/fish/vv_edit_var(var_name, var_value)
	switch(var_name)
		if(NAMEOF(src, status))
			if(var_value != FISH_DEAD && var_value != FISH_ALIVE)
				var_value = var_value ? FISH_ALIVE : FISH_DEAD
			set_status(var_value)
		if(NAMEOF(src, size))
			if(!isnum(var_value) || var_value == 0)
				return FALSE
			update_size_and_weight(var_value, weight)
		if(NAMEOF(src, weight))
			if(!isnum(var_value) || var_value == 0)
				return FALSE
			update_size_and_weight(size, var_value)
		if(NAMEOF(src, fish_flags))
			var/old_fish_flags = fish_flags
			fish_flags = var_value
			if((old_fish_flags ^ fish_flags) & FISH_DO_FLOP_ANIM) //the flopping flag wasn't added nor removed
				return TRUE
			if(fish_flags & FISH_DO_FLOP_ANIM)
				RegisterSignal(src, COMSIG_ATOM_TEMPORARY_ANIMATION_START, PROC_REF(on_temp_animation))
			else
				UnregisterSignal(src, COMSIG_ATOM_TEMPORARY_ANIMATION_START)
			check_flopping()
		else
			return ..()

	return TRUE

/// Checks if our current environment lets us live.
/obj/item/reagent_containers/food/snacks/fish/proc/proper_environment(temp_range_min = required_temperature_min, temp_range_max = required_temperature_max)
	if(!loc)
		return TRUE

	if(is_type_in_typecache(loc, SSfishing.fish_safe_turfs_by_type[type]))
		return TRUE
	if(required_fluid_type != FISH_FLUID_AIR && !HAS_TRAIT(src, TRAIT_FISH_AMPHIBIOUS))
		return FALSE
	return TRUE

/obj/item/reagent_containers/food/snacks/fish/proc/process_health(seconds_per_tick)
	var/health_change = 0
	if(!proper_environment())
		health_change -= 2.5 //Dying here
	var/starvation_mult = get_starvation_mult()
	if(starvation_mult)
		health_change -= 0.25 * starvation_mult //Starving
	else
		health_change += 0.5 //Slowly healing
	if(HAS_TRAIT(src, TRAIT_FISH_ON_TESLIUM))
		health_change -= 0.65

	if(!health_change)
		return

	health_change *= seconds_per_tick
	if(health_change < 0)
		damage_fish(-health_change)
	else
		repair_damage(health_change)

///Used to damage this fish while it's still alive. Prevents the fish from taking damage beyond the integrity_failure threshold
/obj/item/reagent_containers/food/snacks/fish/proc/damage_fish(amount)
	if(status == FISH_DEAD || amount <= 0)
		return
	var/current_integrity = get_integrity()
	take_damage(min(amount, current_integrity - max_integrity * integrity_failure), sound_effect = FALSE, armor_penetration = 100)

/// fish dies when its integrity reaches 50%
/obj/item/reagent_containers/food/snacks/fish/atom_break(damage_flag)
	. = ..()
	set_status(FISH_DEAD)

/obj/item/reagent_containers/food/snacks/fish/repair_damage(amount)
	. = ..()
	if(!. || !bites_amount)
		return
	var/current_integrity = get_integrity()
	var/old_integrity = current_integrity - amount
	var/old_max_integrity_diff = max_integrity - old_integrity
	var/percent = (max_integrity - current_integrity)  / old_max_integrity_diff
	var/bites_to_recover = bites_amount * percent
	regenerate_bites(bites_to_recover)

/obj/item/reagent_containers/food/snacks/fish/proc/regenerate_bites(amount)
	amount = min(amount, bites_amount)
	if(amount <= 0)
		return
	bites_amount -= amount
	generate_fish_reagents(amount)

/// returns a value between 0 and 1 representing how much integrity the fish has before dying (atom_break)
/obj/item/reagent_containers/food/snacks/fish/proc/get_health_percentage()
	var/max_health = max_integrity * (1 - integrity_failure)
	var/death_thres = max_integrity - max_health
	return CLAMP01((get_integrity() - death_thres) / max_health)

/// Returns tracked_fish_by_type but flattened and without the items in the blacklist, also shuffled if shuffle is TRUE.
/obj/item/reagent_containers/food/snacks/fish/proc/get_aquarium_fishes(shuffle = FALSE, blacklist)
	. = list()
	for(var/obj/item/reagent_containers/food/snacks/fish/fish in loc)
		. += fish
	. -= blacklist
	if(shuffle)
		. = shuffle(.)
	return .

#define PAUSE_BETWEEN_PHASES 15
#define PAUSE_BETWEEN_FLOPS 2
#define FLOP_COUNT 2
#define FLOP_DEGREE 20
#define FLOP_SINGLE_MOVE_TIME 1.5
#define JUMP_X_DISTANCE 5
#define JUMP_Y_DISTANCE 6

/// This flopping animation played while the fish is alive.
/obj/item/reagent_containers/food/snacks/fish/proc/flop_animation()
	var/pause_between = PAUSE_BETWEEN_PHASES + rand(1, 5) //randomized a bit so fish are not in sync
	animate(src, time = pause_between, loop = -1)
	//move nose down and up
	for(var/_ in 1 to FLOP_COUNT)
		var/matrix/up_matrix = matrix()
		up_matrix.Turn(FLOP_DEGREE)
		var/matrix/down_matrix = matrix()
		down_matrix.Turn(-FLOP_DEGREE)
		animate(transform = down_matrix, time = FLOP_SINGLE_MOVE_TIME, loop = -1)
		animate(transform = up_matrix, time = FLOP_SINGLE_MOVE_TIME, loop = -1)
		animate(transform = matrix(), time = FLOP_SINGLE_MOVE_TIME, loop = -1, easing = BOUNCE_EASING | EASE_IN)
		animate(time = PAUSE_BETWEEN_FLOPS, loop = -1)
	//bounce up and down
	animate(time = pause_between, loop = -1, flags = ANIMATION_PARALLEL)
	var/jumping_right = FALSE
	var/up_time = 3 * FLOP_SINGLE_MOVE_TIME / 2
	for(var/_ in 1 to FLOP_COUNT)
		jumping_right = !jumping_right
		var/x_step = jumping_right ? JUMP_X_DISTANCE/2 : -JUMP_X_DISTANCE/2
		animate(time = up_time, pixel_y = JUMP_Y_DISTANCE , pixel_x=x_step, loop = -1, flags= ANIMATION_RELATIVE, easing = BOUNCE_EASING | EASE_IN)
		animate(time = up_time, pixel_y = -JUMP_Y_DISTANCE, pixel_x=x_step, loop = -1, flags= ANIMATION_RELATIVE, easing = BOUNCE_EASING | EASE_OUT)
		animate(time = PAUSE_BETWEEN_FLOPS, loop = -1)

#undef PAUSE_BETWEEN_PHASES
#undef PAUSE_BETWEEN_FLOPS
#undef FLOP_COUNT
#undef FLOP_DEGREE
#undef FLOP_SINGLE_MOVE_TIME
#undef JUMP_X_DISTANCE
#undef JUMP_Y_DISTANCE

/// Starts flopping animation
/obj/item/reagent_containers/food/snacks/fish/proc/start_flopping()
	if(HAS_TRAIT(src, TRAIT_FISH_FLOPPING))  //Requires update_transform/animate_wrappers to be less restrictive.
		return
	ADD_TRAIT(src, TRAIT_FISH_FLOPPING, TRAIT_GENERIC)
	flop_animation()

/// Stops flopping animation
/obj/item/reagent_containers/food/snacks/fish/proc/stop_flopping()
	if(HAS_TRAIT(src, TRAIT_FISH_FLOPPING))
		REMOVE_TRAIT(src, TRAIT_FISH_FLOPPING, TRAIT_GENERIC)
		animate(src, transform = matrix()) //stop animation

/// Refreshes flopping animation after temporary animation finishes
/obj/item/reagent_containers/food/snacks/fish/proc/on_temp_animation(datum/source, animation_duration)
	if(animation_duration > 0)
		addtimer(CALLBACK(src, PROC_REF(refresh_flopping)), animation_duration)

/obj/item/reagent_containers/food/snacks/fish/proc/refresh_flopping()
	if(HAS_TRAIT(src, TRAIT_FISH_FLOPPING))
		flop_animation()

///The multiplier of the factor of size and weight of the fish, used to determinate the raw price before exponentation
#define FISH_PRICE_MULTIPLIER 0.01
///This makes each additional unit of fish weight and size yields diminishing marginal returns.
#define FISH_PRICE_CURVE_EXPONENT 0.85
/**
 * past this threshold, the price of fish will plateu even faster.
 * This stops particularly huge fish from being an overly efficient way to make money
 * that bypasses price elasticity by selling fewer units.
 */
#define FISH_PRICE_SOFT_CAP_THRESHOLD 6000
///The second exponent used for soft-capping the fish price.
#define FISH_PRICE_SOFT_CAP_EXPONENT 0.86

///Returns the price of this fish, for the fish export.
/obj/item/reagent_containers/food/snacks/fish/proc/get_export_price(price, elasticity_percent)
	var/size_weight_exponentation = (size * weight * FISH_PRICE_MULTIPLIER)^FISH_PRICE_CURVE_EXPONENT
	var/raw_price = price + size_weight_exponentation
	if(raw_price >= FISH_PRICE_SOFT_CAP_THRESHOLD + 1)
		var/soft_cap = (raw_price - FISH_PRICE_SOFT_CAP_THRESHOLD)^FISH_PRICE_SOFT_CAP_EXPONENT
		raw_price = FISH_PRICE_SOFT_CAP_THRESHOLD + soft_cap
	if(HAS_TRAIT(src, TRAIT_FISH_LOW_PRICE)) //Avoid printing money by simply ordering fish and sending it back.
		raw_price *= 0.05
	return raw_price * elasticity_percent

#undef FISH_PRICE_MULTIPLIER
#undef FISH_PRICE_CURVE_EXPONENT
#undef FISH_PRICE_SOFT_CAP_THRESHOLD
#undef FISH_PRICE_SOFT_CAP_EXPONENT

/obj/item/reagent_containers/food/snacks/fish/proc/get_happiness_value()
	var/happiness_value = 0
	if(fish_flags & FISH_FLAG_PETTED)
		happiness_value++
	if(get_hunger() < 0.5)
		happiness_value++
	if(proper_environment())
		happiness_value += 2
	if(bites_amount) // ouch
		happiness_value -= 2
	if(get_health_percentage() < 0.6)
		happiness_value -= 1
	return clamp(happiness_value, FISH_SAD, FISH_VERY_HAPPY)

/obj/item/reagent_containers/food/snacks/fish/attack_self(mob/living/user)
	. = ..()
	try_pet_fish(user)

/obj/item/reagent_containers/food/snacks/fish/proc/try_pet_fish(mob/living/user)
	if(status == FISH_DEAD)
		to_chat(user, span_warning("You try to pet [src], but [p_theyre()] motionless!"))
		return FALSE
	if(!proper_environment())
		to_chat(user, span_warning("You try to pet [src], but [p_theyre()] not feeling well!"))
		return FALSE

	return pet_fish(user, FALSE)

/obj/item/reagent_containers/food/snacks/fish/proc/pet_fish(mob/living/user, in_aquarium)
	if(fish_flags & FISH_FLAG_PETTED)
		if(in_aquarium)
			to_chat(user, span_warning("[src] runs away from your finger as you dip it into the water!"))
		else
			to_chat(user, span_warning("You try to pet [src] but [p_they()] squirms away!"))
		return FALSE
	fish_flags |= FISH_FLAG_PETTED
	new /obj/effect/temp_visual/heart(get_turf(src))
	if((/datum/fish_trait/predator in fish_traits) && prob(50))
		if(in_aquarium)
			user.visible_message(
				span_warning("[src] dances around before biting [user]!"),
				span_warning("[src] dances around before biting you!"),
				vision_distance = DEFAULT_MESSAGE_RANGE - 3,
			)
		else
			user.visible_message(
				span_warning("[src] bites [user]'s hand!"),
				span_warning("You pet [src] as you hold it, only for [p_them()] to happily bite back!"),
				vision_distance = DEFAULT_MESSAGE_RANGE - 3,
			)
		var/body_zone = pick(BODY_ZONE_R_ARM, BODY_ZONE_L_ARM)
		user.apply_damage((force * 0.2) + w_class * 2, BRUTE, body_zone, user.run_armor_check(body_zone))
		playsound(src,'sound/items/weapons/bite.ogg', 45, TRUE, -1)
	else
		if(in_aquarium)
			to_chat(user, span_notice("[src] dances around!"))
		else
			to_chat(user, span_notice("You pet [src] as you hold it."))
		playsound(src, 'sound/items/weapons/thudswoosh.ogg', 30, TRUE, -1)
	addtimer(CALLBACK(src, PROC_REF(undo_petted)), 30 SECONDS)
	return TRUE

/obj/item/reagent_containers/food/snacks/fish/proc/undo_petted()
	fish_flags &= ~FISH_FLAG_PETTED

///Proc called in trophy_fishes.dm, when a fish is mounted on persistent trophy mounts
/obj/item/reagent_containers/food/snacks/fish/proc/persistence_save(list/data)
	return

///Proc called in trophy_fishes.dm, when a persistent fishing trophy mount is spawned and the fish instantiated
/obj/item/reagent_containers/food/snacks/fish/proc/persistence_load(list/data)
	return

#undef FISH_SAD
#undef FISH_VERY_HAPPY
#undef FISH_SUBMERGING_THRESHOLD
#undef STARVING_FISH_SUBMERGING_THRESHOLD

/obj/item/reagent_containers/food/snacks/fish/carp
	name = "carp"
	desc = "A common freshwater fish with large scales."
	icon_state = "carp"
	fish_id = "carp"
	average_size = 60
	average_weight = 2000
	required_fluid_type = FISH_FLUID_FRESHWATER
	fishing_difficulty_modifier = 5
	fish_movement_type = /datum/fish_movement/choppy
	sellprice = 10

/obj/item/reagent_containers/food/snacks/fish/clownfish
	name = "clownfish"
	desc = "A small, brightly colored tropical fish."
	icon_state = "clownfish"
	fish_id = "clownfish"
	average_size = 15
	average_weight = 200
	required_fluid_type = FISH_FLUID_SALTWATER
	required_temperature_min = 24
	required_temperature_max = 28
	fishing_difficulty_modifier = 5
	fish_movement_type = /datum/fish_movement/zippy
	beauty = 5
	sellprice = 40
	favorite_bait = list(
		list(
			FISH_BAIT_TYPE = FISH_BAIT_FOODTYPE,
			FISH_BAIT_VALUE = MEAT,
		),
	)

/obj/item/reagent_containers/food/snacks/fish/angler
	name = "anglerfish"
	desc = "A deep-sea predator with a bioluminescent lure."
	icon_state = "angler"
	fish_id = "angler"
	average_size = 50
	average_weight = 1500
	required_fluid_type = FISH_FLUID_SALTWATER
	required_temperature_min = 2
	required_temperature_max = 8
	fishing_difficulty_modifier = 15
	fish_movement_type = /datum/fish_movement/plunger
	sellprice = 15
	favorite_bait = list(
		list(
			FISH_BAIT_TYPE = FISH_BAIT_FOODTYPE,
			FISH_BAIT_VALUE = MEAT,
		),
	)
	fish_traits = list(/datum/fish_trait/predator, /datum/fish_trait/heavy)

/obj/item/reagent_containers/food/snacks/fish/eel
	name = "eel"
	desc = "A slippery, snake-like fish."
	icon_state = "eel"
	fish_id = "eel"
	average_size = 80
	average_weight = 800
	required_fluid_type = FISH_FLUID_FRESHWATER
	fishing_difficulty_modifier = 10
	fish_movement_type = /datum/fish_movement/zippy
	sellprice = 5
	favorite_bait = list(
		list(
			FISH_BAIT_TYPE = FISH_BAIT_FOODTYPE,
			FISH_BAIT_VALUE = MEAT,
		),
	)
	fish_traits = list(/datum/fish_trait/lubed)

/obj/item/reagent_containers/food/snacks/fish/shrimp
	name = "shrimp"
	desc = "As shrimple as that."
	icon_state = "shrimp"
	fish_id = "shrimp"
	average_size = 8
	average_weight = 50
	required_fluid_type = FISH_FLUID_SALTWATER
	fishing_difficulty_modifier = -5
	fish_movement_type = /datum/fish_movement/slow
	beauty = 2
	sellprice = 2
	feeding_frequency = 10 MINUTES
	favorite_bait = list(
		list(
			FISH_BAIT_TYPE = FISH_BAIT_FOODTYPE,
			FISH_BAIT_VALUE = VEGETABLES,
		),
	)

/obj/item/reagent_containers/food/snacks/fryfish
	icon = 'icons/roguetown/misc/fish.dmi'
	trash = null
	list_reagents = list(/datum/reagent/consumable/nutriment = 10)
	tastes = list("fish" = 1)
	name = "cooked fish"
	faretype = FARE_POOR
	desc = "Abyssor's bounty, make sure to eat the eyes!"
	icon_state = "carpcooked"
	foodtype = MEAT
	dropshrink = 0.6

/obj/item/reagent_containers/food/snacks/fryfish/carp
	name = "cooked carp"
	icon_state = "carpcooked"
	faretype = FARE_IMPOVERISHED

/obj/item/reagent_containers/food/snacks/fryfish/clownfish
	name = "cooked clownfish"
	icon_state = "clownfishcooked"
	faretype = FARE_FINE

/obj/item/reagent_containers/food/snacks/fryfish/angler
	name = "cooked anglerfish"
	icon_state = "anglercooked"
	faretype = FARE_NEUTRAL

/obj/item/reagent_containers/food/snacks/fryfish/eel
	name = "cooked eel"
	icon_state = "eelcooked"
	faretype = FARE_NEUTRAL

/obj/item/reagent_containers/food/snacks/fryfish/swordfish
	name = "cooked swordfish"

/obj/item/reagent_containers/food/snacks/fryfish/shrimp
	icon_state = "shrimpcooked"
	name = "cooked shrimp"
	tastes = list("shrimp" = 1)

/obj/item/reagent_containers/food/snacks/fryfish/carp/rare
	eat_effect = list(/datum/status_effect/buff/foodbuff, /datum/status_effect/buff/blessed)

/obj/item/reagent_containers/food/snacks/fryfish/clownfish/rare
	eat_effect = list(/datum/status_effect/buff/foodbuff, /datum/status_effect/buff/blessed)

/obj/item/reagent_containers/food/snacks/fryfish/angler/rare
	eat_effect = list(/datum/status_effect/buff/foodbuff, /datum/status_effect/buff/blessed)

/obj/item/reagent_containers/food/snacks/fryfish/eel/rare
	eat_effect = list(/datum/status_effect/buff/foodbuff, /datum/status_effect/buff/blessed)

/*	.................   Chocolate Fish   ................... */

/obj/item/reagent_containers/food/snacks/fryfish/carp/attackby(obj/item/I, mob/living/user, params)
	..()
	if(user.mind)
		short_cooktime = (50 - ((user.get_skill_level(/datum/skill/craft/cooking))*8))
	var/found_table = locate(/obj/structure/table) in (loc)
	if(isturf(loc)&& (found_table))
		if(istype(I, /obj/item/reagent_containers/food/snacks/chocolate))
			playsound(get_turf(user), 'sound/foley/dropsound/food_drop.ogg', 40, TRUE, -1)
			to_chat(user, span_notice("Creating an insult against cooking..."))
			if(do_after(user, short_cooktime, src))
				new /obj/item/reagent_containers/food/snacks/chocolate_carp(loc)
				qdel(I)
				qdel(src)
				user.mind.add_sleep_experience(/datum/skill/craft/cooking, (user.STAINT*0.5))

/obj/item/reagent_containers/food/snacks/chocolate_carp
	name = "le carp au chocolat"
	desc = "Plundered grenzlehoftian chocolate drizzled over fish, this abomination is a delicacy to dark elves. In this case the eyeless cave fish has been substituted for a carp."
	icon_state = "chocolatecarp"
	bitesize = 4
	list_reagents = list(/datum/reagent/consumable/nutriment = SNACK_DECENT)
	tastes = list("a horrible clash of salty fish and sweet chocolate" = 1)
	faretype = FARE_IMPOVERISHED
	rotprocess = null
	dropshrink = 0.6
	eat_effect = /datum/status_effect/buff/foodbuff
